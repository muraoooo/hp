<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Design Session Landing</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@500;700;800&family=Noto+Sans+JP:wght@400;500;700&display=swap');

      :root {
        --bg-1: #060d1a;
        --bg-2: #11243b;
        --text: #f3f8ff;
        --muted: #9fb5d6;
        --accent: #67ffd6;
        --line: rgba(153, 190, 255, 0.24);
        --panel: rgba(8, 18, 35, 0.56);
      }

      * { box-sizing: border-box; }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
        color: var(--text);
        font-family: 'Noto Sans JP', sans-serif;
        background:
          radial-gradient(circle at 82% 9%, rgba(103, 255, 214, 0.14), transparent 36%),
          radial-gradient(circle at 12% 92%, rgba(112, 152, 255, 0.14), transparent 42%),
          linear-gradient(180deg, var(--bg-1), var(--bg-2));
      }

      #scene {
        position: fixed;
        inset: 0;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .shell {
        width: min(1100px, 96vw);
        border: 1px solid var(--line);
        border-radius: 28px;
        background:
          radial-gradient(circle at 8% 8%, rgba(103, 255, 214, 0.16), transparent 34%),
          var(--panel);
        backdrop-filter: blur(14px);
        box-shadow: 0 26px 90px rgba(0, 0, 0, 0.45);
        padding: 26px;
      }

      .badge {
        display: inline-block;
        padding: 7px 11px;
        border-radius: 999px;
        border: 1px solid rgba(103, 255, 214, 0.4);
        color: var(--accent);
        font: 700 11px/1 'Manrope', sans-serif;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hero {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1.5fr 1fr;
        gap: 20px;
      }

      h1 {
        margin: 0;
        font: 800 clamp(2rem, 5.1vw, 4.3rem) / 1.02 'Manrope', sans-serif;
        letter-spacing: -0.03em;
      }

      .lead {
        margin: 14px 0 0;
        max-width: 64ch;
        color: var(--muted);
        line-height: 1.85;
        font-size: clamp(0.95rem, 2.2vw, 1.08rem);
      }

      .actions {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .btn {
        display: inline-block;
        text-decoration: none;
        padding: 12px 17px;
        border-radius: 12px;
        font: 700 0.85rem/1 'Manrope', sans-serif;
        letter-spacing: 0.04em;
        transition: transform 170ms ease;
      }

      .btn:hover { transform: translateY(-2px); }

      .btn-primary {
        color: #031222;
        background: linear-gradient(90deg, #67ffd6, #95f4ff);
      }

      .btn-ghost {
        color: #d8e6ff;
        background: rgba(22, 38, 63, 0.42);
        border: 1px solid rgba(194, 214, 255, 0.36);
      }

      .quote {
        align-self: end;
        border: 1px solid rgba(169, 198, 255, 0.28);
        border-radius: 16px;
        padding: 14px;
        background: rgba(11, 21, 39, 0.4);
      }

      .quote-title {
        margin: 0;
        color: #d8e7ff;
        font: 700 0.8rem/1 'Manrope', sans-serif;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      .quote p {
        margin: 9px 0 0;
        color: #9db6da;
        font-size: 0.9rem;
        line-height: 1.65;
      }

      .principles {
        margin-top: 18px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
      }

      .card {
        border: 1px solid rgba(160, 194, 252, 0.24);
        border-radius: 14px;
        padding: 12px;
        background: rgba(10, 21, 40, 0.38);
      }

      .card strong {
        display: block;
        font: 700 0.84rem/1.3 'Manrope', sans-serif;
        color: #e7f0ff;
      }

      .card span {
        display: block;
        margin-top: 6px;
        color: #9cb2d4;
        font-size: 0.78rem;
        line-height: 1.6;
      }

      .foot {
        margin-top: 14px;
        color: #88a4cc;
        font-size: 0.8rem;
      }

      @media (max-width: 920px) {
        .hero { grid-template-columns: 1fr; }
      }

      @media (max-width: 760px) {
        .principles { grid-template-columns: 1fr 1fr; }
      }

      @media (max-width: 560px) {
        .shell { padding: 18px; border-radius: 18px; }
        .principles { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div id="scene" aria-hidden="true"></div>

    <div class="overlay">
      <section class="shell">
        <span class="badge">Design Critique Session / Final Draft</span>
        <div class="hero">
          <div>
            <h1>
              4人のデザイナーが議論して、
              <br />
              このファーストビューに絞りました。
            </h1>
            <p class="lead">
              目を引く動き、読みやすい情報設計、信頼を生む余白、そして行動につながる導線。
              それぞれの主張をぶつけて、最終的に「かっこよくて、成果が出る」1ページへ統合しています。
            </p>
            <div class="actions">
              <a class="btn btn-primary" href="#">無料相談を予約する</a>
              <a class="btn btn-ghost" href="#">制作事例を見る</a>
            </div>
          </div>
          <aside class="quote">
            <h2 class="quote-title">Final Decision</h2>
            <p>
              「派手さだけ」でも「堅さだけ」でもない。
              視線の流れを設計し、最初の3秒で印象を残す。
              そのうえで、問い合わせ導線まで迷わせない構成を採用。
            </p>
          </aside>
        </div>

        <div class="principles">
          <article class="card">
            <strong>Motion</strong>
            <span>背景の立体アニメーションで、静的サイトとの差を作る。</span>
          </article>
          <article class="card">
            <strong>Typography</strong>
            <span>太い見出しと余白で、メッセージの優先順位を明確化。</span>
          </article>
          <article class="card">
            <strong>Trust</strong>
            <span>透明感のあるUIで先進性と誠実さを同時に伝える。</span>
          </article>
          <article class="card">
            <strong>Conversion</strong>
            <span>CTAを視線終点に配置し、次の行動を迷わせない。</span>
          </article>
        </div>

        <div class="foot">操作: キューブにカーソルを合わせると反応 / クリックでハイライト</div>
      </section>
    </div>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';

      const mount = document.getElementById('scene');
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x071426, 18, 52);

      const camera = new THREE.PerspectiveCamera(58, window.innerWidth / window.innerHeight, 0.1, 120);
      camera.position.set(0, 5, 21);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      mount.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x7ea4d4, 0.72));

      const keyLight = new THREE.DirectionalLight(0x9dd8ff, 1.18);
      keyLight.position.set(8, 14, 10);
      scene.add(keyLight);

      const rimLight = new THREE.PointLight(0x67ffd6, 2.2, 48, 2);
      rimLight.position.set(-9, 3, 7);
      scene.add(rimLight);

      const cubeGroup = new THREE.Group();
      scene.add(cubeGroup);

      const cubes = [];
      const grid = window.innerWidth < 680 ? 7 : 10;
      const spacing = 1.84;
      const boxGeo = new THREE.BoxGeometry(1.1, 1.1, 1.1);
      const baseColor = new THREE.Color('#34567e');
      const hoverColor = new THREE.Color('#95f4ff');
      const activeColor = new THREE.Color('#67ffd6');

      for (let x = -grid; x <= grid; x++) {
        for (let z = -grid; z <= grid; z++) {
          if (Math.hypot(x, z) > grid + 0.5) continue;

          const mat = new THREE.MeshStandardMaterial({
            color: baseColor.clone().offsetHSL((Math.random() - 0.5) * 0.05, 0, 0),
            metalness: 0.3,
            roughness: 0.36,
          });

          const cube = new THREE.Mesh(boxGeo, mat);
          cube.position.set(x * spacing, (Math.random() - 0.5) * 0.4, z * spacing);
          cube.rotation.set(Math.random() * 0.4, Math.random() * Math.PI, Math.random() * 0.2);
          cube.userData.baseY = cube.position.y;
          cube.userData.active = false;
          cubes.push(cube);
          cubeGroup.add(cube);
        }
      }

      cubeGroup.rotation.x = -0.55;
      cubeGroup.position.y = -3.8;

      const mouse = new THREE.Vector2(999, 999);
      const raycaster = new THREE.Raycaster();
      let hovered = null;

      window.addEventListener('pointermove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      window.addEventListener('pointerleave', () => {
        mouse.set(999, 999);
        if (hovered && !hovered.userData.active) {
          hovered.material.color.copy(baseColor);
          hovered = null;
        }
      });

      window.addEventListener('click', () => {
        if (!hovered) return;
        hovered.userData.active = !hovered.userData.active;
        hovered.material.color.copy(hovered.userData.active ? activeColor : hoverColor);
      });

      const clock = new THREE.Clock();

      const animate = () => {
        const t = clock.getElapsedTime();

        cubeGroup.rotation.z = Math.sin(t * 0.18) * 0.04;
        cubeGroup.rotation.y = Math.sin(t * 0.13) * 0.08;

        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObjects(cubes, false)[0]?.object || null;

        if (hovered && hovered !== hit && !hovered.userData.active) {
          hovered.material.color.copy(baseColor);
          hovered.scale.setScalar(1);
        }

        if (hit && !hit.userData.active) {
          hit.material.color.lerp(hoverColor, 0.2);
          hit.scale.lerp(new THREE.Vector3(1.22, 1.22, 1.22), 0.2);
        }

        hovered = hit;

        for (const cube of cubes) {
          const wave = Math.sin(t * 1.36 + cube.position.x * 0.16 + cube.position.z * 0.2) * 0.12;
          cube.position.y = cube.userData.baseY + wave;
          cube.rotation.y += 0.0018;

          if (cube !== hovered) {
            cube.scale.lerp(new THREE.Vector3(1, 1, 1), 0.12);
          }

          if (!cube.userData.active && cube !== hovered) {
            cube.material.color.lerp(baseColor, 0.06);
          }

          cube.material.emissive.set(cube.userData.active ? activeColor.clone().multiplyScalar(0.16) : 0x000000);
        }

        camera.position.x += ((mouse.x * 1.8) - camera.position.x) * 0.03;
        camera.position.y += ((5 + mouse.y * 0.9) - camera.position.y) * 0.03;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      };

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
